/*
ООО ПрогрессГео
Мутовкин. А.Н. 2025
P_regulator.lib

!!! при первом анализе делаем Tемпература C°  выше целевой
 
Первое. При старте программы надо обязательно пройти Mode 0.
текущая температура должна быть выше установленной
определяет макс. мин точки от установленного Kf.
вычисляет новый Kf. 
после выхода из режима функция возвращает 100.

*******************************************************************************
в Mode 1, происходит регулирровка этого коэффициента. в предела гистерезиса 0.1

*******************************************************************************	
	//-------------- outputs 
	//Tmax
	//Tmin
	//
	//-------------- inputs
	//Mode
	//Tstop
	//Tcurent
	//-------------- inputs outputs
	//Kf
	//
	
*/

#include "stm32f10x.h"                  // Device header
#include "stm32f10x_gpio.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <stdint.h>


#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif


//************надо инициализировать в основном коде *****************
// свой выбранный пин как выход PoolPush активный сигнал 1.
//++++++++++++включение обмотки S ***********************************
#define  Start  GPIO_SetBits(GPIOA, GPIO_Pin_6);    // менять на свой пин
#define  Stop   GPIO_ResetBits(GPIOA, GPIO_Pin_6);  // менять на свой пин
#define  DELAY300 delay_ms(300);                    // менять только на свою функцию
#define  DELAY500 delay_ms(500); 
#define  DELAY1000 delay_ms(1000);                  // менять только на свою функцию
extern struct menu {
	 int IdMenu;
	u32 SetTemp;
	float TemperStop;
	double SetPWR;
	double SetHisteresis;
//	void(*menu1)(int);  // Функция	 

}Menu;
//******************************************************
int cnt_average=4;  // анализ мин. мах. точек от целевой температуры
double ADC_Work_currentmotor = 1000; // ток мотора в работе >1000, но меньше <1500, при простое около 970
#define ADC_CURRENT_MOTOR =1000
int EnableMotor(_Bool St);
_Bool point_up=FALSE;// условие при первом вхождении в функцию в Mode 0. 
int avegage_count =4;                     // анализ, когда температура выше установленной, повышается
int Starter(uint16_t ADC,int status);
  // при первом анализе делаем Kf=1.0 C°  (попробывать =0 тогда коипрессор выключится при достижении Tstop) 
	// Mode 0 возвр. разницу температур между min и целевой Kf 
	// point_up=FALSE; при первом входе, температура долхна быть выше целевой.
	//-------------- outputs 
	//Tmax
	//Tmin
	//
	//-------------- inputs
	//Mode
	//Tstop
	//Tcurent
	//reset
	//-------------- inputs outputs
	//Kf
//********************************************************************************** 
	
	int P_regulator(int Mode,	// Mode 0: -> анализ в cnt переходов, для определения Kf
														// при завершении retun=100. до, кол. циклов 0...до cnt
														// Mode 1:  регулировка Kf +- 0.1°

	          double Tstop,		// установленная температура морозилки
						 double Tmin,		// после Mode 0 возвращает значения мин.
						 double Tmax,		// после Mode 0 возвращает значения мах.
					double Tcurent,		// температура морозильника.
						//   double Kf,		// при вхождении =1(0). при выходе = высчитанный.
					double Kmin,
					double Kmax,	
						 _Bool reset );	// сброс функции к первоначальному состоянию.
							

//***********************************************************************************
//********************* как работать *****************************						
	/*
	1. включить Mode0 c Kf=1(0). ждать завершения возврат return =100.		
     теперь есть разница от Tstop и Tmin. в Kf.
  2. включить Mode1 подстрройка Kf. возвращает  Kf=Kf-+0.1;	return 1.
	3. включить опять Mode0 c новым Kf.
	4. включить Mode1 подстрройка Kf	
  5. продолжаем с п.1, пока не добъёмся нужного гистерезиса +-0.1
	6. остаёмся в Mode1.			
   эти режимы включаем до стабилизации Tstop.
   процесс долгий.
	*/						 
							 
//********************** как работает компрессор холодильника ***********			 
/*
		Компрессор имеет две обмотки S-стартер и М- мотор.
		Чтобы его запустить надо подать на S 220в в течении 0.3....0.5 сек.
    после снять напряжение.
*/
int starer_run(uint16_t ADC,// значения ацп датчика тока, у меня свой на ферритовом кольце 16х12х4 6000H
	                        // первичная 2.5м мгтф д=0.12.  вторичная мгтф 6-ть витков д=1мм.
	                        // при простое 800-970
                          // работа 1200...1400.
                          // стартер 2000...2300.
                          // в единицах АЦП stm32f103
	          double SetPWR,// в основном коде нужен PWM с максимально шириной 20мс. (50Гц=20мс) 
							            // у меня Tim3  PA7 выход на силовой ключ для (М-обмотка)мотора
						 	  int Run,// Запуск Run=True, после возвращает Run=False.
						              // DELAY300 определяет время удержания запуска.
						              // DELAY1000 проверяет, запустился мотор или нет.
						              // ADC_Work_currentmotor > 1000 и меньше 1500.  работает.
						 _Bool start, // True-мотор запустился, False нет.
						int Mode);    // взависимости от режима подключать темперпатуру остановки
	
/****************** как работает стартет ********************************************
			if(ADC>=2000)//starter
			{
				Start; 
				DELAY300
				Stop;
				DELAY1000
							if((ADC > ADC_Work_currentmotor) && (ADC<=2000))
							{Run=FALSE;
				          start=TRUE;
							}
			}
			else
				Stop;			
***************************************************************************************/
/*
******************** запуск в программе *********************************************
int ret
int mode;
 double Tstop=-10;
  double Tmin, Tmax; // return to
	double Kf=1;
	double cmp=0;
........
...........
_Bool mode0_finish =FALSE;
mode=0;
// Tcurent значение от датчика температуры
while(1)
 {
 ...............
 ..............
 ..............
 ...............
 
 ................
 if(!mode0_finish)
 {
ret = P_regulator(mode,Tstop,Tmin,Tmax,Tcurent,Kf,FALSE);
 if(ret=100)
   { 
	 mode0_finish=TRUE;
	 mode=1;
	 }					 
 }	
*****************************
 if(mode0_finish) 
  {
	//
	P_regulator(mode,Tstop,Tmin,Tmax,Tcurent,Kf,FALSE);		
	
	 cmp=  abs(Tcurent-Tstop);
 
 if(cmp <=0.1)
   mode0_finish=TRUE;
    else
			{mode0_finish= FALSE;
			mode=0;
			}
	}


   

}
							 */
							 
							 
							 
							 
							 
							 